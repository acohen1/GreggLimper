"""
Cache manager coordinating channel state, memos, and ingestion.

The :class:`GLCache` singleton is the public entry point for the cache package.

It exposes high-level read and write helpers that wrap the lower-level modules
responsible for channel state, memo persistence, formatting, and ingestion.

Consumers obtain the singleton via ``GLCache()`` and call methods like
``add_message`` or ``list_formatted_messages``; tests can also reset the
singleton by clearing ``GLCache._instance`` between runs.
"""

from __future__ import annotations
from typing import ClassVar

import logging
from typing import List

from discord import Client, Message
from discord.abc import User

from gregg_limper.config import cache

from gregg_limper import commands

from .core import process_message_for_rag
from .channel_state import ChannelCacheState
from .initializer import CacheInitializer
from .memo_store import MemoStore
from .serialization import Mode, copy_memo_entry, serialize
from .utils import _frags_preview

logger = logging.getLogger(__name__)


class GLCache:
    """Singleton, channel-aware cache with memoized message formatting."""

    _instance: ClassVar["GLCache | None"] = None

    # Instance attributes
    _states: dict[int, ChannelCacheState]
    _memo_store: MemoStore

    def __new__(cls) -> "GLCache":
        if cls._instance is None:
            # Lazily allocate so a reset between tests can just null out ``_instance``.
            self = super().__new__(cls)
            self._states = {}
            self._memo_store = MemoStore()
            cls._instance = self
        return cls._instance

    # ------------------------------------------------------------------ #
    # WRITE helpers
    # ------------------------------------------------------------------ #

    async def add_message(
        self,
        channel_id: int,
        message_obj: Message,
        ingest: bool = True,
        cache_msg: dict | None = None,
        bot_user: User | None = None,
    ) -> None:
        """
        Record a message in the cache, persist its memo, and optionally queue ingestion.

        A memo record is a dictionary shaped like ``{"author": str, "fragments": [Fragment, ...]}``.
        When ``cache_msg`` is not provided the memo is generated by the formatter, yielding
        fragment objects that can later be serialized into the compact ``llm`` view or the
        full-fidelity ``full`` payload.  Ingestion reuses these memo fragments to seed
        downstream storage (e.g. SQLite or Milvus) when the evaluator signals that the
        message should be persisted beyond the in-memory cache.

        :param channel_id: Discord channel identifier that owns the message.
        :param message_obj: The raw :class:`discord.Message` to append to the channel state.
        :param ingest: Whether the message should be considered for downstream ingestion.
        :param cache_msg: Precomputed memo record to store instead of formatting ``message_obj``.
        :return: ``None``. The internal cache state and memo store are updated in-place.
        """

        state = self._get_state(channel_id)
        msg_id = message_obj.id

        # Check memo existence before mutating so we know if formatting can be skipped.
        memo_present = self._memo_store.has(msg_id)
        # Append first so eviction logic reflects the cache's retention policy.
        evicted_id = state.append(message_obj)
        if evicted_id is not None:
            # Drop any memo tied to the evicted message to keep disk snapshots aligned.
            self._memo_store.delete(evicted_id)

        bot_user = bot_user or getattr(getattr(message_obj, "guild", None), "me", None)

        skip_rag = commands.is_command_message(
            message_obj, bot_user=bot_user
        ) or commands.is_command_feedback(message_obj, bot_user=bot_user)

        if skip_rag:
            if memo_present:
                self._memo_store.delete(msg_id)
            if evicted_id is not None or memo_present:
                self._memo_store.save_channel_snapshot(channel_id, state.message_ids())
            logger.info(
                "Skipped cache memo persistence and RAG ingestion for command message %s",
                msg_id,
            )
            return

        record, _ = await process_message_for_rag(
            message_obj,
            channel_id,
            ingest=ingest,
            cache_msg=cache_msg,
            memo=self._memo_store,
            bot_user=bot_user,
        )

        if not memo_present or evicted_id is not None or cache_msg is not None:
            # Persist the latest retention window whenever memo membership changes.
            self._memo_store.save_channel_snapshot(channel_id, state.message_ids())

        if logger.isEnabledFor(logging.INFO):
            preview = _frags_preview(
                record.get("fragments", []), width_each=20, max_total_chars=200
            )
            # Summarize fragment activity so operators can trace cache churn at INFO level.
            logger.info(
                "Cached msg %s in channel %s (%s) by %s | Frags: %s",
                msg_id,
                channel_id,
                "new" if not memo_present else "reuse",
                record.get("author"),
                preview,
            )

    # ------------------------------------------------------------------ #
    # READ helpers
    # ------------------------------------------------------------------ #

    def _get_state(self, channel_id: int) -> ChannelCacheState:
        try:
            return self._states[channel_id]
        except KeyError as exc:
            raise KeyError(
                f"Channel ID {channel_id} is not configured for caching."
            ) from exc

    def _get_memo_entry(self, channel_id: int, message_id: int) -> dict:
        state = self._get_state(channel_id)
        if not state.contains(message_id):
            raise KeyError(
                f"Message ID {message_id} is not cached for channel {channel_id}."
            )
        return self._memo_store.get(message_id)

    def list_raw_messages(self, channel_id: int, n: int) -> list[Message]:
        """
        Return the raw :class:`discord.Message` objects retained for ``channel_id``.

        The messages are ordered from oldest to newest exactly as they were observed, so the
        result mirrors what subsequent memo serialization will process.

        :param channel_id: Discord channel identifier whose cache should be read.
        :param n: Maximum number of most recent messages to include (default all).
        :return: Live :class:`discord.Message` instances ordered according to cache retention.
        """
        return self._get_state(channel_id).iter_messages(n)

    def list_formatted_messages(
        self, channel_id: int, mode: Mode, n: int | None = None
    ) -> list[dict]:
        """
        Serialize memo records for ``channel_id`` into caller-friendly dictionaries.

        Two serialization ``mode`` values are supported:

        * ``"llm"`` - produces ``{"author": str, "fragments": [fragment.to_llm(), ...]}`` for
          fast language-model prompting.
        * ``"full"`` - returns ``{"author": str, "fragments": [fragment.to_dict(), ...]}``
          preserving every field emitted by the formatter.

        :param channel_id: Discord channel identifier whose cached messages to format.
        :param mode: Serialization mode controlling the payload shape returned.
        :param n: Optional maximum number of most recent messages to include (default all).
        :return: Serialized memo dictionaries ready for transport or rendering.
        """
        state = self._get_state(channel_id)
        messages = state.iter_messages(n)
        formatted: list[dict] = []
        missing: list[int] = []

        for msg in messages:
            try:
                memo_entry = self._memo_store.get(msg.id)
            except KeyError:
                missing.append(msg.id)
                continue
            formatted.append(serialize(memo_entry, mode))

        if missing:
            logger.debug(
                "Skipped %s uncached messages for channel %s: %s",
                len(missing),
                channel_id,
                missing,
            )

        return formatted

    def list_memo_records(
        self, channel_id: int, n: int | None = None
    ) -> list[dict]:
        """
        Return shallow copies of memo records retained for ``channel_id``.

        Each memo copy preserves the ``{"author": str, "fragments": [Fragment, ...]}``
        structure produced by the formatter, but the list of fragments is cloned so callers
        can append or remove entries without mutating the cache's live store.

        :param channel_id: Discord channel identifier whose memo store to inspect.
        :param n: Optional maximum number of most recent messages to include (default all).
        :return: Memo dictionaries safe for experimentation prior to serialization.
        """
        state = self._get_state(channel_id)
        messages = state.iter_messages(n)
        copies: list[dict] = []
        missing: list[int] = []

        for msg in messages:
            try:
                memo_entry = self._memo_store.get(msg.id)
            except KeyError:
                missing.append(msg.id)
                continue
            copies.append(copy_memo_entry(memo_entry))

        if missing:
            logger.debug(
                "Skipped %s uncached messages for channel %s when copying memos: %s",
                len(missing),
                channel_id,
                missing,
            )

        return copies

    def get_formatted_message(
        self, channel_id: int, message_id: int, mode: Mode
    ) -> dict:
        """
        Serialize a single memo record for presentation or transport.

        The same ``mode`` rules as :meth:`list_formatted_messages` apply, so callers can
        choose between the compact ``llm`` form or the exhaustive ``full`` dictionary.

        :param channel_id: Discord channel identifier that owns the message.
        :param message_id: Identifier of the cached message to serialize.
        :param mode: Serialization mode controlling the payload structure (``"llm"`` or ``"full"``).
        :return: Serialized memo dictionary ready for API consumers.
        """
        cache_msg = self._get_memo_entry(channel_id, message_id)
        return serialize(cache_msg, mode)

    def get_memo_record(self, channel_id: int, message_id: int) -> dict:
        """
        Fetch a defensive copy of the memo for ``message_id``.

        The returned structure mirrors the memo store entry—including fragment objects—so
        callers can perform custom serialization or fragment manipulation before deciding
        whether to re-ingest or broadcast the result.

        :param channel_id: Discord channel identifier that owns the message.
        :param message_id: Identifier of the cached message to retrieve.
        :return: Copy of the memo dictionary detached from the live cache.
        """
        cache_msg = self._get_memo_entry(channel_id, message_id)
        return copy_memo_entry(cache_msg)

    # ------------------------------------------------------------------ #
    # INITIALIZATION
    # ------------------------------------------------------------------ #

    async def initialize(self, client: Client, channel_ids: List[int]) -> None:
        """
        Hydrate the cache with historical messages for ``channel_ids``.

        The initializer backfills memo records (``{"author": str, "fragments": [...]}``) and
        persists per-channel message order so that later reads and ingestion operate on a
        consistent snapshot. Reinitializing with the same channels becomes a no-op to avoid
        redundant formatter and network load.

        :param client: Discord client used to fetch channel history during hydration.
        :param channel_ids: Channel identifiers that should be cached.
        :return: ``None``. The singleton is primed with fresh state and memo data.
        """
        if self._states and set(self._states.keys()) == set(channel_ids):
            # Fast-path repeated initializations to avoid redundant history fetches.
            logger.info("Cache already initialized with same channel IDs. Skipping.")
            return

        self._states = {
            cid: ChannelCacheState(cid, cache.CACHE_LENGTH) for cid in channel_ids
        }
        # Toss any previously memoized entries so hydration rebuilds from disk cleanly.
        self._memo_store.reset()

        initializer = CacheInitializer(self, self._memo_store)
        await initializer.hydrate(client, channel_ids)

    # ------------------------------------------------------------------ #
    # MAINTENANCE
    # ------------------------------------------------------------------ #

    def clear_cache(self, channel_id: int) -> None:
        state = self._get_state(channel_id)
        self._memo_store.remove_many(state.message_ids())
        state.clear()
