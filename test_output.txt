============================= test session starts =============================
platform win32 -- Python 3.12.2, pytest-8.4.1, pluggy-1.6.0 -- C:\Users\Alex\AppData\Local\Programs\Python\Python312\python.exe
cachedir: .pytest_cache
rootdir: c:\Users\Alex\Projects\GreggLimper
configfile: pytest.ini
plugins: anyio-4.11.0, dash-2.17.1, asyncio-0.24.0
asyncio: mode=Mode.STRICT, default_loop_scope=None
collecting ... collected 5 items

tests/gregg_limper/response/test_accumulator.py::test_check_completeness_complete PASSED [ 20%]
tests/gregg_limper/response/test_accumulator.py::test_check_completeness_continue PASSED [ 40%]
tests/gregg_limper/response/test_accumulator.py::test_accumulate_response_loop FAILED [ 60%]
tests/gregg_limper/response/test_accumulator.py::test_accumulate_response_no_config PASSED [ 80%]
tests/gregg_limper/response/test_accumulator.py::test_accumulate_response_history_reset FAILED [100%]

================================== FAILURES ===================================
________________________ test_accumulate_response_loop ________________________

    @pytest.mark.asyncio
    async def test_accumulate_response_loop():
        # Mock payload
        payload = MagicMock()
        payload.messages = [{"role": "user", "content": "Hello"}]
        payload.history.messages = []
    
        # Mock runner
        runner = AsyncMock()
        # First call (initial) is done outside, so runner is called for loop 1 and loop 2
        # Loop 1: returns " part 2", incomplete
        # Loop 2: returns " part 3", complete
        runner.side_effect = [
            ("part 2", []),
            ("part 3", [])
        ]
    
        with patch("gregg_limper.response.accumulator.check_completeness", new_callable=AsyncMock) as mock_check:
            # check_completeness called:
            # 1. Initial response -> False
            # 2. Initial + part 2 -> False
            # 3. Initial + part 2 + part 3 -> True
            mock_check.side_effect = [False, False, True]
    
            core.DETAIL_CHECK_MODEL_ID = "test-model"
            core.DETAIL_CHECK_MAX_LOOPS = 3
    
>           final_response = await accumulate_response("Part 1", payload, runner)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\gregg_limper\response\test_accumulator.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

initial_response = 'Part 1', payload = <MagicMock id='2261761436240'>
runner = <AsyncMock id='2261761404192'>

    async def accumulate_response(
        initial_response: str,
        payload: PromptPayload,
        runner: Callable[[list[dict[str, str]]], Awaitable[tuple[str, list[dict[str, str]]]]]
    ) -> str:
        """
        Iteratively accumulates the response until it is deemed complete.
    
        Args:
            initial_response: The text generated in the first pass.
            payload: The original prompt payload (history, context, etc.).
            runner: A async function that takes a list of messages and returns (response_text, final_messages).
                    This should be `_run_with_tools` or a wrapper around the simple chat client.
        """
        current_response = initial_response
    
        # If no check model is configured, just return the initial response
        if not core.DETAIL_CHECK_MODEL_ID:
            return current_response
    
        loops = 0
        max_loops = core.DETAIL_CHECK_MAX_LOOPS
    
        # We need a mutable list of messages to append to
        # We start with the original messages from the payload
        # NOTE: payload.messages includes system prompt, tool specs, context, and history.
        # We shouldn't modify payload.messages in place if it's used elsewhere, but here we are consuming it.
        while loops < max_loops:
>           is_complete = await check_completeness(current_response, history_messages)
                                                                     ^^^^^^^^^^^^^^^^
E           NameError: name 'history_messages' is not defined

src\gregg_limper\response\accumulator.py:55: NameError
___________________ test_accumulate_response_history_reset ____________________

    @pytest.mark.asyncio
    async def test_accumulate_response_history_reset():
        # Verify that the history is reset in each loop
        payload = MagicMock()
        # 1 system, 1 user
        payload.messages = [{"role": "system", "content": "Sys"}, {"role": "user", "content": "Hello"}]
        payload.history.messages = []
    
        runner = AsyncMock()
        # Initial: "Part 1"
        # Loop 1: "Part 2"
        runner.side_effect = [
            ("Part 2", [])
        ]
    
        with patch("gregg_limper.response.accumulator.oai.check_completeness", new_callable=AsyncMock) as mock_check:
            # 1. Initial "Part 1" -> Incomplete
            # 2. "Part 1 Part 2" -> Complete
            mock_check.side_effect = [False, True]
    
            core.DETAIL_CHECK_MODEL_ID = "test-model"
            core.DETAIL_CHECK_MAX_LOOPS = 3
    
>           final_response = await accumulate_response("Part 1", payload, runner)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\gregg_limper\response\test_accumulator.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

initial_response = 'Part 1', payload = <MagicMock id='2261761437632'>
runner = <AsyncMock id='2261762449216'>

    async def accumulate_response(
        initial_response: str,
        payload: PromptPayload,
        runner: Callable[[list[dict[str, str]]], Awaitable[tuple[str, list[dict[str, str]]]]]
    ) -> str:
        """
        Iteratively accumulates the response until it is deemed complete.
    
        Args:
            initial_response: The text generated in the first pass.
            payload: The original prompt payload (history, context, etc.).
            runner: A async function that takes a list of messages and returns (response_text, final_messages).
                    This should be `_run_with_tools` or a wrapper around the simple chat client.
        """
        current_response = initial_response
    
        # If no check model is configured, just return the initial response
        if not core.DETAIL_CHECK_MODEL_ID:
            return current_response
    
        loops = 0
        max_loops = core.DETAIL_CHECK_MAX_LOOPS
    
        # We need a mutable list of messages to append to
        # We start with the original messages from the payload
        # NOTE: payload.messages includes system prompt, tool specs, context, and history.
        # We shouldn't modify payload.messages in place if it's used elsewhere, but here we are consuming it.
        while loops < max_loops:
>           is_complete = await check_completeness(current_response, history_messages)
                                                                     ^^^^^^^^^^^^^^^^
E           NameError: name 'history_messages' is not defined

src\gregg_limper\response\accumulator.py:55: NameError
=========================== short test summary info ===========================
FAILED tests/gregg_limper/response/test_accumulator.py::test_accumulate_response_loop - NameError: name 'history_messages' is not defined
FAILED tests/gregg_limper/response/test_accumulator.py::test_accumulate_response_history_reset - NameError: name 'history_messages' is not defined
========================= 2 failed, 3 passed in 2.18s =========================
